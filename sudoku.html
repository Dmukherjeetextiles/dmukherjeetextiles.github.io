<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Google Tag Manager -->
    <script>
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-K2MKRGPZ');
    </script>
    <title>Sudoku Pro | Classic Dark</title>
    
    <style>
        :root {
            /* Restored Original Colors */
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-green: #4CAF50;
            --accent-blue: #2196F3;
            --accent-red: #ff3e3e;
            --text-dim: #888;
            --text-bright: #ffffff;
            --cell-bg: #252525;
            --cell-border: #333;
            --cell-related: #2a2d30;
            --cell-selected: #34495e;
            --board-edge: #000000;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-bright);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-container {
            display: flex;
            gap: 30px;
            padding: 25px;
            background: var(--panel-color);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            border: 1px solid #333;
            max-width: 95vw;
            max-height: 95vh;
        }

        /* Board Section */
        .board-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            width: min(72vh, 500px);
            height: min(72vh, 500px);
            background: var(--board-edge);
            border: 3px solid var(--board-edge);
            user-select: none;
        }

        .cell {
            background: var(--cell-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(18px, 3.5vh, 26px);
            cursor: pointer;
            border: 1px solid var(--cell-border);
            position: relative;
            transition: background 0.1s;
        }

        /* 3x3 Grid Thicker Borders */
        .cell:nth-child(3n) { border-right: 3px solid var(--board-edge); }
        .cell:nth-child(9n) { border-right: 1px solid var(--cell-border); }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 3px solid var(--board-edge); }

        /* Original Themed States */
        .cell.fixed { color: var(--text-dim); font-weight: bold; }
        .cell.user-val { color: var(--accent-blue); }
        .cell.error { color: var(--accent-red); background: #3d1a1a !important; }
        .cell.selected { background: var(--cell-selected) !important; box-shadow: inset 0 0 12px var(--accent-blue); z-index: 2; }
        .cell.related { background: var(--cell-related); }

        .notes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            font-size: clamp(8px, 1.2vh, 10px);
            color: var(--accent-blue);
            opacity: 0.6;
            pointer-events: none;
        }
        .notes-grid div { display: flex; align-items: center; justify-content: center; }

        /* UI Sidebar */
        .info-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
        }

        h1 { margin: 0 0 15px 0; font-size: 1.6rem; letter-spacing: 4px; color: var(--accent-green); text-transform: uppercase; }

        .status-box {
            background: #111;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--accent-red);
            margin-bottom: 20px;
        }

        #timer { font-family: monospace; font-size: 2.4rem; display: block; color: var(--text-bright); }
        .mistakes-text { color: var(--text-dim); font-size: 0.8rem; text-transform: uppercase; margin-top: 5px; }
        #mistakes { color: var(--accent-red); font-weight: bold; }

        .controls { display: flex; flex-direction: column; gap: 10px; flex-grow: 1; }
        
        select {
            background: #111; color: white; border: 1px solid #444; padding: 10px; border-radius: 4px; cursor: pointer; margin-bottom: 10px;
        }

        button {
            background: #333; border: none; color: white; padding: 12px; border-radius: 4px;
            font-weight: bold; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: #444; filter: brightness(1.2); }
        button:active { transform: scale(0.95); }
        button.primary { background: var(--accent-green); margin-top: auto; }
        button.active { background: var(--accent-blue); }

        /* Numpad */
        .numpad {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 6px;
            width: 100%;
        }
        .num-btn { background: #252525; border: 1px solid #444; padding: 12px 0; font-size: 1.2rem; }
        .num-btn:hover { border-color: var(--accent-green); color: var(--accent-green); }

        /* Mobile Viewports */
        @media (max-width: 850px) {
            body { overflow-y: auto; align-items: flex-start; padding: 10px; height: auto; }
            #game-container {
                flex-direction: column;
                align-items: center;
                max-height: none;
                width: 100%;
                gap: 20px;
                padding: 15px;
            }
            .sudoku-board { width: 92vw; height: 92vw; }
            .info-panel { width: 100%; }
            h1 { text-align: center; font-size: 1.2rem; }
            .numpad { gap: 4px; }
        }
    </style>
     <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HXK18460W4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HXK18460W4');
</script>
</head>
<body>

    <div id="game-container">
        <div class="board-wrapper">
            <div id="sudoku-board" class="sudoku-board"></div>
            
            <div class="numpad">
                <button class="num-btn" onclick="game.handleInput(1)">1</button>
                <button class="num-btn" onclick="game.handleInput(2)">2</button>
                <button class="num-btn" onclick="game.handleInput(3)">3</button>
                <button class="num-btn" onclick="game.handleInput(4)">4</button>
                <button class="num-btn" onclick="game.handleInput(5)">5</button>
                <button class="num-btn" onclick="game.handleInput(6)">6</button>
                <button class="num-btn" onclick="game.handleInput(7)">7</button>
                <button class="num-btn" onclick="game.handleInput(8)">8</button>
                <button class="num-btn" onclick="game.handleInput(9)">9</button>
            </div>
        </div>

        <div class="info-panel">
            <h1>Sudoku</h1>
            
            <div class="status-box">
                <span id="timer">00:00</span>
                <div class="mistakes-text">Mistakes: <span id="mistakes">0</span>/3</div>
            </div>

            <div class="controls">
                <select id="difficulty" onchange="game.startNewGame()">
                    <option value="easy">Easy Mode</option>
                    <option value="medium" selected>Medium Mode</option>
                    <option value="hard">Hard Mode</option>
                </select>
                
                <button id="note-toggle" onclick="game.toggleNoteMode()">Notes: OFF</button>
                <button onclick="game.undo()">Undo Last Move</button>
                <button onclick="game.erase()">Erase Cell</button>
                <button onclick="game.hint()">Hint</button>
                <button class="primary" onclick="game.startNewGame()">New Game</button>
            </div>
        </div>
    </div>

    <script>
        class SudokuEngine {
            constructor() {
                this.board = Array(9).fill().map(() => Array(9).fill(0));
                this.solution = [];
                this.initialBoard = [];
                this.notes = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
                this.selected = { r: 0, c: 0 };
                this.history = [];
                this.mistakes = 0;
                this.isNoteMode = false;
                this.timer = 0;
                this.timerInterval = null;
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                this.initKeyboard();
                this.startNewGame();
            }

            playSfx(type) {
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                const now = this.audioCtx.currentTime;
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);

                if (type === 'select') {
                    osc.frequency.setValueAtTime(440, now);
                    gain.gain.setValueAtTime(0.02, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    osc.start(); osc.stop(now + 0.05);
                } else if (type === 'input') {
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(); osc.stop(now + 0.1);
                } else if (type === 'error') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(110, now);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(); osc.stop(now + 0.2);
                }
            }

            startNewGame() {
                clearInterval(this.timerInterval);
                this.generateSolution();
                this.solution = this.board.map(row => [...row]);
                this.createPuzzle();
                this.initialBoard = this.board.map(row => [...row]);
                this.notes = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
                this.mistakes = 0;
                this.timer = 0;
                this.history = [];
                this.render();
                this.startTimer();
                document.getElementById('mistakes').innerText = '0';
            }

            generateSolution() {
                this.board = Array(9).fill().map(() => Array(9).fill(0));
                const fill = (b) => {
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (b[r][c] === 0) {
                                let ns = [1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
                                for (let n of ns) {
                                    if (this.isValid(b, r, c, n)) {
                                        b[r][c] = n;
                                        if (fill(b)) return true;
                                        b[r][c] = 0;
                                    }
                                }
                                return false;
                            }
                        }
                    }
                    return true;
                };
                fill(this.board);
            }

            isValid(b, r, c, n) {
                for (let i = 0; i < 9; i++) if (b[r][i] === n || b[i][c] === n) return false;
                let rs = Math.floor(r/3)*3, cs = Math.floor(c/3)*3;
                for (let i=0; i<3; i++) for (let j=0; j<3; j++) if (b[rs+i][cs+j] === n) return false;
                return true;
            }

            createPuzzle() {
                const diff = document.getElementById('difficulty').value;
                const holes = { 'easy': 30, 'medium': 45, 'hard': 55 }[diff];
                let count = 0;
                while (count < holes) {
                    let r = Math.floor(Math.random()*9), c = Math.floor(Math.random()*9);
                    if (this.board[r][c] !== 0) {
                        this.board[r][c] = 0;
                        count++;
                    }
                }
            }

            handleInput(n) {
                const { r, c } = this.selected;
                if (this.initialBoard[r][c] !== 0) return;

                if (this.isNoteMode) {
                    this.playSfx('select');
                    if (this.notes[r][c].has(n)) this.notes[r][c].delete(n);
                    else this.notes[r][c].add(n);
                } else {
                    if (this.board[r][c] === n) return;
                    this.history.push(JSON.stringify(this.board));
                    if (n !== this.solution[r][c]) {
                        this.mistakes++;
                        this.playSfx('error');
                        document.getElementById('mistakes').innerText = this.mistakes;
                        if (this.mistakes >= 3) {
                            alert("GAME OVER: 3 Mistakes. Starting over...");
                            this.startNewGame();
                            return;
                        }
                    } else {
                        this.playSfx('input');
                    }
                    this.board[r][c] = n;
                    this.notes[r][c].clear();
                }
                this.render();
                this.checkWin();
            }

            toggleNoteMode() {
                this.isNoteMode = !this.isNoteMode;
                const b = document.getElementById('note-toggle');
                b.classList.toggle('active');
                b.innerText = `Notes: ${this.isNoteMode ? 'ON' : 'OFF'}`;
            }

            undo() {
                if (this.history.length > 0) {
                    this.board = JSON.parse(this.history.pop());
                    this.render();
                }
            }

            erase() {
                const { r, c } = this.selected;
                if (this.initialBoard[r][c] === 0) {
                    this.board[r][c] = 0;
                    this.notes[r][c].clear();
                    this.render();
                }
            }

            hint() {
                const { r, c } = this.selected;
                if (this.board[r][c] === 0) {
                    this.board[r][c] = this.solution[r][c];
                    this.playSfx('input');
                    this.render();
                    this.checkWin();
                }
            }

            render() {
                const boardEl = document.getElementById('sudoku-board');
                boardEl.innerHTML = '';
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        const val = this.board[r][c];

                        if (val !== 0) {
                            cell.innerText = val;
                            if (this.initialBoard[r][c] !== 0) cell.classList.add('fixed');
                            else cell.classList.add('user-val');
                            if (val !== this.solution[r][c]) cell.classList.add('error');
                        } else {
                            const ng = document.createElement('div');
                            ng.className = 'notes-grid';
                            for (let i = 1; i <= 9; i++) {
                                const n = document.createElement('div');
                                n.innerText = this.notes[r][c].has(i) ? i : '';
                                ng.appendChild(n);
                            }
                            cell.appendChild(ng);
                        }

                        if (this.selected.r === r && this.selected.c === c) cell.classList.add('selected');
                        else if (this.selected.r === r || this.selected.c === c || 
                            (Math.floor(r/3) === Math.floor(this.selected.r/3) && Math.floor(c/3) === Math.floor(this.selected.c/3))) {
                            cell.classList.add('related');
                        }

                        cell.onclick = () => { 
                            this.selected = { r, c }; 
                            this.playSfx('select');
                            this.render(); 
                        };
                        boardEl.appendChild(cell);
                    }
                }
            }

            initKeyboard() {
                window.onkeydown = (e) => {
                    if (e.key >= 1 && e.key <= 9) this.handleInput(parseInt(e.key));
                    if (e.key === 'Backspace' || e.key === 'Delete') this.erase();
                    if (e.key === 'ArrowUp' && this.selected.r > 0) this.selected.r--;
                    if (e.key === 'ArrowDown' && this.selected.r < 8) this.selected.r++;
                    if (e.key === 'ArrowLeft' && this.selected.c > 0) this.selected.c--;
                    if (e.key === 'ArrowRight' && this.selected.c < 8) this.selected.c++;
                    this.render();
                };
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    const m = Math.floor(this.timer/60).toString().padStart(2,'0');
                    const s = (this.timer%60).toString().padStart(2,'0');
                    document.getElementById('timer').innerText = `${m}:${s}`;
                }, 1000);
            }

            checkWin() {
                const win = this.board.every((row, r) => row.every((v, c) => v === this.solution[r][c]));
                if (win) {
                    clearInterval(this.timerInterval);
                    alert("PUZZLE SOLVED!");
                }
            }
        }

        const game = new SudokuEngine();
    </script>
</body>
</html>